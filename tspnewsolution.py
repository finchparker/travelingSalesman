{
 "cells": [
  {
   "cell_type": "code",
   "execution_count": 18,
   "metadata": {},
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "50312\n",
      "[1, 138, 864, 385, 564, 927, 284, 577, 214, 878, 919, 48, 735, 795, 10, 30, 515, 907, 816, 147, 308, 501, 871, 765, 362, 665, 203, 638, 391, 622, 914, 269, 680, 483, 988, 757, 357, 830, 773, 897, 941, 760, 895, 693, 178, 620, 613, 285, 706, 543, 131, 366, 79, 423, 588, 171, 319, 957, 312, 478, 768, 653, 234, 742, 63, 163, 764, 966, 33, 556, 803, 924, 904, 123, 222, 91, 860, 226, 940, 549, 125, 746, 330, 867, 375, 652, 971, 129, 754, 673, 946, 350, 596, 196, 334, 67, 128, 681, 566, 962, 189, 938, 662, 624, 54, 296, 364, 584, 541, 933, 983, 422, 902, 187, 691, 733, 257, 242, 348, 394, 263, 301, 637, 925, 311, 591, 332, 664, 452, 654, 26, 490, 686, 280, 12, 415, 767, 542, 726, 61, 597, 727, 462, 37, 540, 28, 808, 493, 959, 72, 555, 469, 529, 928, 430, 22, 911, 255, 271, 306, 986, 503, 645, 945, 401, 487, 711, 425, 812, 655, 272, 688, 991, 495, 450, 78, 813, 254, 753, 794, 137, 299, 433, 444, 352, 721, 747, 82, 446, 388, 903, 516, 797, 514, 83, 90, 683, 397, 872, 960, 225, 775, 331, 161, 581, 634, 174, 537, 160, 958, 250, 328, 18, 873, 992, 386, 456, 437, 743, 162, 150, 207, 964, 31, 921, 484, 531, 489, 633, 383, 908, 560, 262, 47, 371, 930, 611, 661, 868, 4, 806, 177, 761, 843, 410, 81, 573, 459, 231, 120, 116, 370, 651, 406, 321, 827, 534, 486, 454, 942, 237, 751, 745, 326, 783, 313, 298, 807, 38, 658, 248, 153, 793, 782, 20, 668, 114, 619, 608, 963, 417, 609, 24, 796, 961, 172, 614, 922, 246, 626, 714, 952, 833, 523, 734, 533, 979, 524, 77, 674, 251, 854, 630, 520, 236, 144, 108, 467, 618, 390, 86, 215, 261, 610, 320, 671, 339, 223, 832, 980, 567, 276, 88, 440, 631, 535, 882, 629, 676, 75, 740, 395, 969, 204, 893, 569, 497, 429, 598, 412, 183, 739, 477, 164, 718, 480, 461, 333, 973, 909, 934, 660, 15, 194, 792, 603, 407, 905, 57, 602, 722, 838, 220, 923, 778, 325, 399, 670, 409, 491, 730, 182, 551, 420, 901, 682, 2, 460, 884, 883, 802, 474, 76, 590, 356, 929, 554, 831, 657, 265, 372, 981, 173, 604, 879, 134, 359, 139, 784, 729, 464, 115, 438, 235, 605, 695, 270, 95, 65, 323, 387, 889, 696, 169, 505, 287, 155, 713, 146, 180, 900, 295, 184, 373, 42, 318, 669, 159, 191, 679, 179, 451, 110, 130, 288, 731, 400, 984, 846, 997, 677, 804, 468, 798, 539, 329, 113, 943, 836, 558, 912, 737, 11, 87, 393, 840, 376, 488, 337, 258, 972, 316, 188, 96, 414, 335, 132, 158, 193, 703, 636, 360, 303, 378, 823, 545, 593, 294, 233, 336, 565, 209, 292, 617, 185, 382, 817, 56, 678, 133, 479, 748, 694, 324, 439, 212, 435, 404, 240, 705, 175, 948, 953, 102, 728, 98, 639, 466, 396, 421, 252, 815, 894, 377, 68, 344, 381, 918, 701, 999, 279, 181, 920, 851, 268, 887, 93, 424, 367, 481, 881, 310, 993, 151, 32, 59, 27, 472, 625, 232, 97, 822, 23, 641, 772, 192, 355, 64, 642, 103, 856, 809, 616, 841, 157, 666, 465, 499, 245, 875, 16, 595, 441, 443, 353, 39, 205, 256, 289, 62, 1000, 521, 275, 154, 845, 358, 715, 538, 5, 239, 536, 199, 109, 766, 885, 744, 290, 165, 3, 752, 512, 104, 811, 892, 492, 126, 716, 644, 839, 587, 470, 709, 216, 66, 530, 850, 987, 931, 976, 937, 800, 517, 498, 724, 304, 416, 553, 307, 58, 656, 982, 568, 528, 970, 621, 200, 29, 327, 579, 403, 260, 100, 967, 801, 229, 338, 858, 453, 343, 643, 702, 599, 689, 202, 34, 122, 471, 627, 148, 635, 43, 297, 35, 985, 36, 457, 594, 368, 939, 442, 699, 842, 502, 659, 915, 482, 572, 52, 73, 649, 906, 532, 426, 880, 13, 570, 349, 458, 684, 606, 211, 436, 968, 769, 45, 411, 475, 206, 107, 112, 118, 266, 402, 117, 142, 346, 302, 550, 526, 413, 998, 974, 828, 508, 121, 758, 863, 647, 989, 825, 848, 648, 557, 398, 156, 476, 300, 708, 855, 380, 576, 518, 612, 805, 494, 170, 201, 575, 780, 419, 835, 916, 392, 582, 697, 238, 741, 345, 143, 418, 820, 913, 291, 956, 690, 522, 562, 826, 692, 719, 281, 384, 168, 899, 779, 870, 547, 190, 111, 21, 592, 996, 136, 519, 978, 427, 428, 434, 965, 74, 60, 546, 511, 445, 763, 600, 509, 787, 7, 322, 847, 852, 243, 463, 71, 585, 994, 732, 990, 347, 149, 947, 309, 94, 888, 762, 53, 601, 824, 273, 771, 910, 8, 834, 221, 267, 578, 17, 19, 513, 340, 781, 755, 675, 759, 227, 369, 305, 374, 586, 525, 507, 877, 876, 506, 315, 770, 995, 623, 544, 219, 717, 548, 704, 954, 389, 405, 241, 749, 750, 455, 819, 485, 866, 186, 949, 791, 55, 432, 101, 314, 646, 342, 810, 25, 857, 286, 710, 975, 247, 363, 195, 790, 583, 571, 253, 379, 365, 814, 799, 700, 510, 198, 951, 447, 50, 317, 650, 632, 41, 408, 264, 141, 896, 725, 663, 859, 955, 944, 687, 249, 821, 167, 932, 85, 500, 218, 667, 849, 580, 473, 844, 84, 46, 44, 354, 277, 504, 40, 837, 853, 829, 615, 140, 80, 124, 217, 756, 283, 723, 818, 640, 448, 869, 282, 351, 496, 166, 672, 361, 789, 449, 9, 777, 935, 89, 861, 563, 736, 890, 698, 70, 874, 574, 776, 69, 224, 431, 293, 950, 228, 628, 244, 862, 105, 176, 145, 99, 738, 14, 152, 774, 527, 127, 274, 788, 607, 891, 197, 278, 51, 785, 208, 926, 561, 898, 230, 119, 6, 886, 936, 712, 707, 917, 720, 865, 259, 210, 559, 49, 786, 92, 341, 552, 977, 135, 589, 685, 213, 106, 1]\n"
     ]
    }
   ],
   "source": [
    "l = []         # 이것이다. 이것이 바로 텍스트 파일을 array 로 옮긴 것이다. \n",
    "with open('C:/Users/m_s_park/tsp_input.txt', 'r') as f:\n",
    "    for line in f:\n",
    "        line = line.strip()\n",
    "        if len(line) > 0:\n",
    "            l.append(list(map(int, line.split(','))))\n",
    "\n",
    "import random \n",
    "\n",
    "a = 0 \n",
    "b= []\n",
    "while a < 10 : \n",
    "    tour = random.sample(range(1000),1000)\n",
    "    A=tour.index(0)\n",
    "    tour.pop(A)\n",
    "    tour = [0] + tour + [0]\n",
    "    b.append(tour)\n",
    "    a = a+1 \n",
    "    if a== 10:      # 한마디로 tour 를 10번 만든 것 \n",
    "        break\n",
    "        \n",
    "c = 0 \n",
    "d= []\n",
    "\n",
    "while c <10: \n",
    "    \n",
    "    bb = b[c]        # b는 경로다 c 는 그 경로의 각 행을 따낸 것\n",
    "    e = 0 \n",
    "    f =[]      # 이제부터는 각 경로를 따냈으니까 도시별 이동 거리 합을 구할거임\n",
    "    \n",
    "    while e<1000: \n",
    "        x,y =bb[e], bb[e+1]\n",
    "        ee = l[x][y]        # bb 즉, 각 경로의 1,2번째 도시 간의 좌표를 구하고\n",
    "        f.append(ee)        # 그 거리를 l 행렬에서 찾아서 한 줄로 만든후에\n",
    "        e = e+1             # 다 더할 계획\n",
    "        if e == 1000 :\n",
    "            break\n",
    "            \n",
    "    sum1 = sum(f)     # 각 경로들마다 걸리는 거리의 총합을 구한것 \n",
    "    d.append(sum1)      \n",
    "    c=c+1\n",
    "    \n",
    "    if c ==10 :\n",
    "        break\n",
    "\n",
    "d_min = min(d)        # 거리들 중에서 가장 작은 값 캐치해내는 것 \n",
    "AA=d.index(d_min)     # 그 최솟값을 찾아내는 과정 \n",
    "parent = b[AA]        # 그 최솟값을 기록한 경로를 부모로 선정  # 부모로 선정되었으면 위의 과정과 똑같이 경로 재 설정\n",
    "        \n",
    "Bignumber = 0\n",
    "\n",
    "while Bignumber < 200000 :\n",
    "    \n",
    "    parent = parent[1:1000]\n",
    "\n",
    "    g = 0 \n",
    "    child_list=[]    # child 리스트를 만드는 과정 시작 \n",
    "    while g < 20:\n",
    "        [i,j] = sorted(random.sample(range(1000),2))\n",
    "        child =  parent[:i] + parent[j:j+1] +  parent[i+1:j] + parent[i:i+1] + parent[j+1:];\n",
    "        child = [0] + child + [0]    # child 리스트를 다시 만듬 \n",
    "        # parent list 를 무작위로 섞어서 child 리스트 생성 \n",
    "        child_list.append(child) # child 리스트 한데 모아서  # 근데 이게 또 다른 리스트가 되어 버림\n",
    "        g = g+1 \n",
    "        if g == 20 : \n",
    "            break\n",
    "            # child_list 생성까지는 성공 이 후에 오류 주의 \n",
    "        \n",
    "    parent = [0]+parent+[0]\n",
    "\n",
    "    New_set =[]      # 새로운 set 를 만들어서 \n",
    "    New_set.append(parent)\n",
    "\n",
    "    AAAAA = 0 \n",
    "    while AAAAA < 20:\n",
    "        child_element = child_list[AAAAA]    # 부모와 \n",
    "         \n",
    "        New_set.append(child_element)           # 자식 세대들을 총 병합한다. \n",
    "    \n",
    "        AAAAA = AAAAA + 1 \n",
    "    \n",
    "        if AAAAA == 20:\n",
    "            break\n",
    "        \n",
    "\n",
    "\n",
    "# 병합한 후의 새로운 세트 완성 # 새로운 세트를 완성하고 나면 이제 이 세트에 대한 개별 평가 시작 \n",
    "# New_Set 이거는 그냥 경로일 뿐 \n",
    "\n",
    "    set_number = 0 \n",
    "    new_distance=[]\n",
    "\n",
    "    while set_number < 21 : \n",
    "    \n",
    "        Test_set = New_set[set_number]\n",
    "    \n",
    "        codes =[]\n",
    "        wow = 0 \n",
    "    \n",
    "        while wow<1000:\n",
    "            code1, code2 = Test_set[wow], Test_set[wow+1]\n",
    "            codepoint = l[code1][code2]      # test_set 의 거리 구하는 공식 \n",
    "            codes.append(codepoint)          # 거리 구함 \n",
    "            wow = wow + 1 \n",
    "            if wow == 1000 : \n",
    "                break\n",
    "            \n",
    "        sum_codes = sum(codes)\n",
    "    \n",
    "        new_distance.append(sum_codes)      # 새로운 거리들 \n",
    "    \n",
    "        set_number = set_number + 1 \n",
    "    \n",
    "        if set_number == 21:    # 거리 6개 구하기 끝 \n",
    "            break\n",
    "        \n",
    "    new_min_number = min(new_distance) # 새로운 거리 중에서 작은 것들 찾기  \n",
    "    new_minnum = new_distance.index(new_min_number)  # 제일 작은 거리의 위치 \n",
    "    parent = New_set[new_minnum]\n",
    "    \n",
    "    Bignumber = Bignumber + 1 \n",
    "    if Bignumber == 200000 :\n",
    "        break \n",
    "        \n",
    "print(new_min_number)\n",
    "\n",
    "NUMBER = 0 \n",
    "while NUMBER < 1001 : \n",
    "    parent[NUMBER] = parent[NUMBER] + 1\n",
    "    NUMBER = NUMBER + 1 \n",
    "    if NUMBER == 1001: \n",
    "        print(parent)      #경로 출력 \n",
    "        \n",
    "        \n",
    "f= open(\"tspoutput33.txt\",'w')\n",
    "\n",
    "f = open(\"C:/Users/m_s_park/tspoutput33.txt\", 'wt')\n",
    "f.write(\"\\n\" .join(map(lambda x : str(x), parent )))\n",
    "f.close() # 일단 이거는 된다 "
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 16,
   "metadata": {
    "collapsed": true
   },
   "outputs": [],
   "source": [
    "#55000, 10,10,20 56242 ,1\n",
    "#75000, 10,10,20 53333 ,1\n",
    "#100000, 10,10,20 49398,1\n",
    "#150000, 10,10,20 49539,1\n",
    "#100000, 10,10,20 49539,xxx 이러면 자꾸 겹치게 되는 오류가 뜬다\n",
    "#100000, 10,10,25 50454,1\n",
    "#200000, 10,10,25 50312\n",
    "#200000, 10,10,20"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 20,
   "metadata": {},
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "50312\n",
      "[1, 830, 505, 134, 883, 998, 640, 623, 708, 592, 855, 173, 534, 217, 825, 950, 298, 341, 10, 76, 157, 969, 648, 176, 859, 654, 445, 383, 967, 409, 180, 75, 4, 93, 845, 776, 704, 299, 214, 729, 586, 661, 933, 446, 61, 980, 498, 928, 878, 703, 929, 904, 558, 865, 753, 761, 759, 72, 925, 737, 262, 945, 181, 888, 631, 801, 233, 951, 376, 254, 337, 36, 596, 252, 226, 423, 617, 347, 591, 892, 749, 903, 240, 282, 653, 182, 406, 682, 840, 730, 789, 457, 778, 606, 306, 232, 939, 158, 331, 382, 583, 755, 315, 87, 73, 123, 718, 242, 188, 853, 166, 44, 89, 386, 743, 303, 741, 387, 482, 990, 435, 790, 260, 846, 452, 902, 234, 395, 548, 651, 688, 62, 476, 724, 198, 786, 877, 393, 415, 875, 815, 948, 658, 763, 615, 510, 908, 966, 243, 318, 200, 116, 899, 126, 626, 909, 799, 374, 851, 197, 327, 392, 645, 769, 808, 271, 589, 143, 38, 896, 312, 64, 844, 694, 959, 474, 905, 809, 669, 462, 117, 343, 915, 974, 322, 60, 285, 464, 219, 286, 597, 317, 807, 184, 833, 42, 519, 675, 400, 353, 673, 656, 46, 490, 547, 340, 394, 78, 96, 699, 647, 5, 71, 746, 26, 389, 794, 179, 13, 8, 563, 455, 27, 221, 819, 486, 336, 995, 82, 319, 977, 814, 619, 418, 578, 280, 893, 487, 484, 119, 125, 791, 758, 958, 506, 302, 683, 757, 713, 676, 171, 277, 7, 861, 587, 272, 643, 614, 162, 449, 821, 274, 960, 328, 599, 191, 921, 605, 447, 367, 237, 451, 876, 535, 354, 513, 142, 247, 747, 430, 857, 442, 344, 721, 269, 635, 477, 700, 448, 92, 34, 774, 539, 874, 557, 731, 788, 284, 772, 842, 124, 300, 45, 884, 94, 193, 604, 684, 957, 52, 413, 439, 823, 811, 199, 281, 135, 628, 378, 348, 771, 666, 785, 820, 568, 664, 461, 622, 832, 326, 961, 397, 325, 601, 900, 650, 390, 144, 910, 531, 313, 504, 637, 725, 391, 565, 239, 377, 996, 497, 863, 566, 172, 917, 549, 638, 612, 58, 403, 680, 834, 923, 438, 745, 670, 101, 570, 913, 674, 919, 787, 23, 738, 946, 854, 32, 632, 470, 911, 115, 580, 542, 934, 690, 223, 502, 607, 740, 532, 206, 978, 229, 537, 646, 511, 273, 926, 39, 550, 766, 810, 33, 138, 956, 192, 77, 742, 870, 444, 992, 295, 726, 773, 572, 291, 993, 947, 621, 270, 872, 663, 159, 454, 508, 800, 361, 927, 279, 183, 352, 847, 40, 379, 885, 867, 459, 407, 22, 204, 436, 595, 711, 988, 491, 141, 662, 67, 202, 971, 922, 590, 251, 427, 509, 81, 714, 528, 848, 955, 155, 283, 421, 431, 140, 687, 696, 546, 294, 174, 512, 775, 806, 938, 41, 244, 827, 469, 307, 569, 879, 981, 636, 468, 210, 189, 944, 522, 220, 886, 161, 358, 414, 618, 471, 500, 224, 600, 493, 613, 972, 56, 458, 573, 795, 816, 402, 107, 964, 1000, 3, 103, 148, 113, 178, 127, 208, 949, 659, 401, 838, 831, 372, 472, 768, 196, 24, 629, 616, 364, 74, 894, 677, 780, 712, 147, 106, 698, 160, 881, 305, 120, 744, 321, 931, 826, 576, 105, 154, 345, 15, 346, 31, 216, 324, 57, 443, 717, 357, 83, 241, 804, 553, 388, 203, 136, 705, 91, 655, 369, 19, 380, 812, 63, 163, 862, 59, 98, 584, 639, 297, 349, 999, 213, 633, 164, 249, 334, 720, 499, 781, 609, 561, 828, 194, 112, 733, 693, 748, 257, 545, 350, 310, 530, 837, 970, 323, 594, 475, 551, 657, 841, 9, 912, 689, 554, 428, 411, 11, 852, 582, 817, 668, 907, 108, 95, 17, 523, 783, 940, 710, 858, 709, 608, 335, 976, 88, 268, 230, 719, 419, 942, 667, 695, 131, 79, 803, 906, 494, 649, 792, 481, 525, 122, 2, 736, 483, 130, 311, 333, 65, 585, 85, 866, 963, 937, 100, 167, 259, 429, 735, 368, 466, 652, 485, 540, 121, 467, 533, 492, 702, 501, 641, 342, 727, 363, 25, 642, 644, 473, 114, 228, 593, 156, 381, 564, 496, 968, 434, 891, 777, 236, 567, 320, 6, 994, 338, 706, 314, 245, 478, 936, 190, 802, 518, 541, 686, 625, 70, 762, 517, 920, 952, 290, 424, 129, 187, 750, 90, 991, 579, 329, 610, 986, 69, 864, 417, 20, 520, 560, 678, 137, 916, 362, 869, 488, 871, 598, 779, 84, 524, 723, 681, 514, 365, 932, 716, 611, 456, 574, 50, 924, 211, 889, 355, 836, 399, 235, 672, 385, 556, 267, 145, 752, 215, 620, 868, 177, 118, 962, 225, 784, 930, 818, 943, 359, 14, 901, 49, 97, 287, 185, 258, 882, 577, 463, 979, 54, 460, 526, 918, 133, 997, 292, 301, 516, 110, 132, 489, 153, 205, 231, 507, 835, 935, 266, 954, 316, 212, 660, 575, 898, 793, 873, 751, 288, 404, 201, 432, 880, 80, 515, 503, 253, 887, 227, 480, 770, 973, 559, 412, 55, 765, 30, 356, 330, 261, 627, 289, 860, 441, 984, 238, 975, 152, 914, 149, 538, 581, 782, 797, 86, 701, 555, 985, 479, 16, 707, 371, 332, 987, 51, 43, 671, 296, 813, 111, 692, 850, 989, 829, 839, 734, 218, 304, 366, 739, 756, 250, 521, 165, 66, 263, 246, 588, 453, 293, 150, 104, 99, 433, 275, 370, 715, 767, 440, 35, 109, 207, 527, 186, 47, 754, 416, 895, 396, 408, 420, 536, 805, 685, 256, 169, 562, 732, 630, 465, 222, 728, 276, 102, 209, 168, 843, 170, 265, 764, 495, 264, 373, 68, 405, 450, 760, 248, 603, 28, 425, 437, 552, 544, 965, 634, 890, 897, 856, 953, 422, 983, 128, 18, 571, 308, 529, 309, 278, 624, 722, 195, 375, 53, 543, 679, 398, 151, 798, 360, 602, 351, 824, 21, 410, 665, 339, 146, 982, 426, 139, 29, 37, 822, 796, 255, 48, 384, 849, 697, 12, 691, 175, 941, 1]\n"
     ]
    }
   ],
   "source": [
    "l = []         # 이것이다. 이것이 바로 텍스트 파일을 array 로 옮긴 것이다. \n",
    "with open('C:/Users/m_s_park/tsp_input.txt', 'r') as f:\n",
    "    for line in f:\n",
    "        line = line.strip()\n",
    "        if len(line) > 0:\n",
    "            l.append(list(map(int, line.split(','))))\n",
    "\n",
    "import random \n",
    "\n",
    "a = 0 \n",
    "b= []\n",
    "while a < 10 : \n",
    "    tour = random.sample(range(1000),1000)\n",
    "    A=tour.index(0)\n",
    "    tour.pop(A)\n",
    "    tour = [0] + tour + [0]\n",
    "    b.append(tour)\n",
    "    a = a+1 \n",
    "    if a== 10:      # 한마디로 tour 를 10번 만든 것 \n",
    "        break\n",
    "        \n",
    "c = 0 \n",
    "d= []\n",
    "\n",
    "while c <10: \n",
    "    \n",
    "    bb = b[c]        # b는 경로다 c 는 그 경로의 각 행을 따낸 것\n",
    "    e = 0 \n",
    "    f =[]      # 이제부터는 각 경로를 따냈으니까 도시별 이동 거리 합을 구할거임\n",
    "    \n",
    "    while e<1000: \n",
    "        x,y =bb[e], bb[e+1]\n",
    "        ee = l[x][y]        # bb 즉, 각 경로의 1,2번째 도시 간의 좌표를 구하고\n",
    "        f.append(ee)        # 그 거리를 l 행렬에서 찾아서 한 줄로 만든후에\n",
    "        e = e+1             # 다 더할 계획\n",
    "        if e == 1000 :\n",
    "            break\n",
    "            \n",
    "    sum1 = sum(f)     # 각 경로들마다 걸리는 거리의 총합을 구한것 \n",
    "    d.append(sum1)      \n",
    "    c=c+1\n",
    "    \n",
    "    if c ==10 :\n",
    "        break\n",
    "\n",
    "d_min = min(d)        # 거리들 중에서 가장 작은 값 캐치해내는 것 \n",
    "AA=d.index(d_min)     # 그 최솟값을 찾아내는 과정 \n",
    "parent = b[AA]        # 그 최솟값을 기록한 경로를 부모로 선정  # 부모로 선정되었으면 위의 과정과 똑같이 경로 재 설정\n",
    "        \n",
    "Bignumber = 0\n",
    "\n",
    "while Bignumber < 00000 :\n",
    "    \n",
    "    parent = parent[1:1000]\n",
    "\n",
    "    g = 0 \n",
    "    child_list=[]    # child 리스트를 만드는 과정 시작 \n",
    "    while g < 20:\n",
    "        [i,j] = sorted(random.sample(range(1000),2))\n",
    "        child =  parent[:i] + parent[j:j+1] +  parent[i+1:j] + parent[i:i+1] + parent[j+1:];\n",
    "        child = [0] + child + [0]    # child 리스트를 다시 만듬 \n",
    "        # parent list 를 무작위로 섞어서 child 리스트 생성 \n",
    "        child_list.append(child) # child 리스트 한데 모아서  # 근데 이게 또 다른 리스트가 되어 버림\n",
    "        g = g+1 \n",
    "        if g == 20 : \n",
    "            break\n",
    "            # child_list 생성까지는 성공 이 후에 오류 주의 \n",
    "        \n",
    "    parent = [0]+parent+[0]\n",
    "\n",
    "    New_set =[]      # 새로운 set 를 만들어서 \n",
    "    New_set.append(parent)\n",
    "\n",
    "    AAAAA = 0 \n",
    "    while AAAAA < 20:\n",
    "        child_element = child_list[AAAAA]    # 부모와 \n",
    "         \n",
    "        New_set.append(child_element)           # 자식 세대들을 총 병합한다. \n",
    "    \n",
    "        AAAAA = AAAAA + 1 \n",
    "    \n",
    "        if AAAAA == 20:\n",
    "            break\n",
    "        \n",
    "\n",
    "\n",
    "# 병합한 후의 새로운 세트 완성 # 새로운 세트를 완성하고 나면 이제 이 세트에 대한 개별 평가 시작 \n",
    "# New_Set 이거는 그냥 경로일 뿐 \n",
    "\n",
    "    set_number = 0 \n",
    "    new_distance=[]\n",
    "\n",
    "    while set_number < 21 : \n",
    "    \n",
    "        Test_set = New_set[set_number]\n",
    "    \n",
    "        codes =[]\n",
    "        wow = 0 \n",
    "    \n",
    "        while wow<1000:\n",
    "            code1, code2 = Test_set[wow], Test_set[wow+1]\n",
    "            codepoint = l[code1][code2]      # test_set 의 거리 구하는 공식 \n",
    "            codes.append(codepoint)          # 거리 구함 \n",
    "            wow = wow + 1 \n",
    "            if wow == 1000 : \n",
    "                break\n",
    "            \n",
    "        sum_codes = sum(codes)\n",
    "    \n",
    "        new_distance.append(sum_codes)      # 새로운 거리들 \n",
    "    \n",
    "        set_number = set_number + 1 \n",
    "    \n",
    "        if set_number == 21:    # 거리 6개 구하기 끝 \n",
    "            break\n",
    "        \n",
    "    new_min_number = min(new_distance) # 새로운 거리 중에서 작은 것들 찾기  \n",
    "    new_minnum = new_distance.index(new_min_number)  # 제일 작은 거리의 위치 \n",
    "    parent = New_set[new_minnum]\n",
    "    \n",
    "    Bignumber = Bignumber + 1 \n",
    "    if Bignumber == 200000 :\n",
    "        break \n",
    "        \n",
    "print(new_min_number)\n",
    "\n",
    "NUMBER = 0 \n",
    "while NUMBER < 1001 : \n",
    "    parent[NUMBER] = parent[NUMBER] + 1\n",
    "    NUMBER = NUMBER + 1 \n",
    "    if NUMBER == 1001: \n",
    "        print(parent)      #경로 출력 \n",
    "        \n",
    "        \n",
    "f= open(\"tspoutput33.txt\",'w')\n",
    "\n",
    "f = open(\"C:/Users/m_s_park/tspoutput33.txt\", 'wt')\n",
    "f.write(\"\\n\" .join(map(lambda x : str(x), parent )))\n",
    "f.close() # 일단 이거는 된다 "
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {
    "collapsed": true
   },
   "outputs": [],
   "source": []
  }
 ],
 "metadata": {
  "kernelspec": {
   "display_name": "Python 3",
   "language": "python",
   "name": "python3"
  },
  "language_info": {
   "codemirror_mode": {
    "name": "ipython",
    "version": 3
   },
   "file_extension": ".py",
   "mimetype": "text/x-python",
   "name": "python",
   "nbconvert_exporter": "python",
   "pygments_lexer": "ipython3",
   "version": "3.6.3"
  }
 },
 "nbformat": 4,
 "nbformat_minor": 2
}
